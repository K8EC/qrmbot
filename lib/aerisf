#!/usr/bin/perl -w

# aeris weather forecast
#
# 2-clause BSD license.
# Copyright (c) 2021 molo1134@github. All rights reserved.
#
# requires an API key from aerisweather.com  Place into the file $HOME/.aerisweather as follows:
#
# $client_id = "0123456789abcdef";
# $client_secret = "0123456789abcdef";

use strict;
use utf8;
use feature 'unicode_strings';
binmode(STDOUT, ":utf8");

use Encode qw(decode);
use I18N::Langinfo qw(langinfo CODESET);
use JSON qw( decode_json );
use Math::Round;
use URI::Escape;
use POSIX qw(strftime);

use File::Basename;
use Cwd 'realpath';
use lib dirname(realpath(__FILE__));
use Colors;
use Location;

my $username = $ENV{'USER'} || $ENV{'USERNAME'} || getpwuid($<);

our $client_id = undef;
our $client_secret = undef;

# change this to 0 to always exit with success
our $exitnonzeroonerror = 1;
$exitnonzeroonerror = 0 if $username eq 'eggdrop';

my $apikeyfile = $ENV{'HOME'} . "/.aerisweather";
if (-e ($apikeyfile)) {
  require($apikeyfile);
} else {
  die "error: unable to read file $apikeyfile"
}
die "error: no API key set" unless defined($client_id) and defined($client_secret);

my $short = 0;
my $i = 0;
my $loc;
while ($i <= $#ARGV) {
  if ($ARGV[$i] =~ /--full/) {
    $short = 0;
    $i++;
    next;
  }
  if ($ARGV[$i] =~ /--short/) {
    $short = 1;
    $i++;
    next;
  }
  if (defined($loc)) {
    $loc = $loc . " " . $ARGV[$i];
  } else {
    $loc = $ARGV[$i];
  }
  $i++;
}

# decode command line from locale-specified codeset
my $codeset = langinfo(CODESET);
$loc = decode($codeset, $loc);

if (defined($loc)) {
  $loc =~ s/^\s*//;
  $loc =~ s/\s*$//;
}

if (!defined($loc) or length($loc) == 0) {
  if ($username eq 'eggdrop') {
    print "usage: !wx <location>\n";
  } else {
    print "usage: $0 <location>\n";
  }
  exit $exitnonzeroonerror;
}

my $geo = argToCoords($loc);
$loc = $geo if defined $geo;
my ($lat, $lon) = split(/,/, $geo) if defined($geo);
my $encodedloc = uri_escape($loc);

our %iconToEmojiMap = (
  "blizzard.png" => "üå¨Ô∏èüå®Ô∏è",
  "blizzardn.png" => "üå¨Ô∏èüå®Ô∏è",
  "blowingsnow.png" => undef,
  "blowingsnown.png" => undef,
  "clear.png" => "‚òÄÔ∏è",
  "clearn.png" => "üåô",
  "cloudy.png" => "‚òÅÔ∏è",
  "cloudyn.png" => "‚òÅÔ∏è",
  "cloudyw.png" => "üå¨Ô∏è‚òÅÔ∏è",
  "cloudywn.png" => "üå¨Ô∏è‚òÅÔ∏è",
  "cold.png" => "ü•∂",
  "coldn.png" => "ü•∂",
  "drizzle.png" => "üåßÔ∏è",
  "drizzlen.png" => "üåßÔ∏è",
  "dust.png" => undef,
  "dustn.png" => undef,
  "fair.png" => "üå§Ô∏è",
  "fairn.png" => undef,
  "drizzlef.png" => undef,
  "fdrizzlen.png" => undef,
  "flurries.png" => "üå®Ô∏è",
  "flurriesn.png" => "üå®Ô∏è",
  "flurriesw.png" => "üå¨Ô∏èüå®Ô∏è",
  "flurrieswn.png" => "üå¨Ô∏èüå®Ô∏è",
  "fog.png" => "üå´Ô∏è",
  "fogn.png" => "üå´Ô∏è",
  "freezingrain.png" => "‚ùÑÔ∏è üåßÔ∏è",
  "freezingrainn.png" => "‚ùÑÔ∏è üåßÔ∏è",
  "hazy.png" => undef,
  "hazyn.png" => undef,
  "hot.png" => "üå°Ô∏è",
  "mcloudy.png" => "üå•Ô∏è",
  "mcloudyn.png" => undef,
  "mcloudyr.png" => "üå•Ô∏èüåßÔ∏è",
  "mcloudyrn.png" => undef,
  "mcloudyrw.png" => undef,
  "mcloudyrwn.png" => undef,
  "mcloudys.png" => "üå•Ô∏èüå®Ô∏è",
  "mcloudysn.png" => undef,
  "mcloudysf.png" => undef,
  "mcloudysfn.png" => undef,
  "mcloudysfw.png" => undef,
  "mcloudysfwn.png" => undef,
  "mcloudysw.png" => "üå¨Ô∏èüå•Ô∏èüå®Ô∏è",
  "mcloudyswn.png" => undef,
  "mcloudyt.png" => "üå•Ô∏èüå©Ô∏è",
  "mcloudytn.png" => undef,
  "mcloudytw.png" => "üå¨Ô∏èüå•Ô∏èüå©Ô∏è",
  "mcloudytwn.png" => undef,
  "mcloudyw.png" => "üå¨Ô∏èüå•Ô∏è",
  "mcloudywn.png" => undef,
  "pcloudy.png" => "‚õÖ",
  "pcloudyn.png" => undef,
  "pcloudyr.png" => "‚õÖüåßÔ∏è",
  "pcloudyrn.png" => undef,
  "pcloudyrw.png" => undef,
  "pcloudyrwn.png" => undef,
  "pcloudys.png" => "‚õÖüå®Ô∏è",
  "pcloudysn.png" => undef,
  "pcloudysf.png" => undef,
  "pcloudysfn.png" => undef,
  "pcloudysfw.png" => undef,
  "pcloudysfwn.png" => undef,
  "pcloudysw.png" => "üå¨Ô∏è‚õÖüå®Ô∏è",
  "pcloudyswn.png" => undef,
  "pcloudyt.png" => "‚õÖüå©Ô∏è",
  "pcloudytn.png" => undef,
  "pcloudytw.png" => "üå¨Ô∏è‚õÖüå©Ô∏è",
  "pcloudytwn.png" => undef,
  "pcloudyw.png" => "üå¨Ô∏è‚õÖ",
  "pcloudywn.png" => undef,
  "rain.png" => "üåßÔ∏è",
  "rainn.png" => "üåßÔ∏è",
  "rainandsnow.png" => "üåßÔ∏èüå®Ô∏è",
  "rainandsnown.png" => "üåßÔ∏èüå®Ô∏è",
  "raintosnow.png" => "üåßÔ∏èüå®Ô∏è",
  "raintosnown.png" => "üåßÔ∏èüå®Ô∏è",
  "rainw.png" => "üå¨Ô∏èüåßÔ∏è",
  "rainwn.png" => "üå¨Ô∏èüåßÔ∏è",
  "showers.png" => "üåßÔ∏è",
  "showersn.png" => "üåßÔ∏è",
  "showersw.png" => "üå¨Ô∏èüåßÔ∏è",
  "showerswn.png" => "üå¨Ô∏èüåßÔ∏è",
  "sleet.png" => undef,
  "sleetn.png" => undef,
  "sleetsnow.png" => undef,
  "sleetsnown.png" => undef,
  "smoke.png" => undef,
  "smoken.png" => undef,
  "snow.png" => "üå®Ô∏è",
  "snown.png" => "üå®Ô∏è",
  "snoww.png" => "üå¨Ô∏èüå®Ô∏è",
  "snowwn.png" => "üå¨Ô∏èüå®Ô∏è",
  "snowshowers.png" => "üå®Ô∏è",
  "snowshowersn.png" => "üå®Ô∏è",
  "snowshowersw.png" => "üå¨Ô∏èüå®Ô∏è",
  "snowshowerswn.png" => "üå¨Ô∏èüå®Ô∏è",
  "snowtorain.png" => "üå®Ô∏èüåßÔ∏è",
  "snowtorainn.png" => "üå®Ô∏èüåßÔ∏è",
  "sunny.png" => "‚òÄÔ∏è",
  "sunnyn.png" => "üåô",
  "sunnyw.png" => "üå¨Ô∏è‚òÄÔ∏è",
  "sunnywn.png" => "üå¨Ô∏èüåô",
  "tstorm.png" => "‚õàÔ∏è",
  "tstormn.png" => "‚õàÔ∏è",
  "tstorms.png" => "‚õàÔ∏è",
  "tstormsn.png" => "‚õàÔ∏è",
  "tstormsw.png" => "üå¨Ô∏è‚õàÔ∏è",
  "tstormswn.png" => "üå¨Ô∏è‚õàÔ∏è",
  "wind.png" => "üå¨Ô∏è",
  "windn.png" => "üå¨Ô∏è",
  "wintrymix.png" => "üå®Ô∏èüåßÔ∏è",
  "wintrymixn.png" => "üå®Ô∏èüåßÔ∏è",
);

my $url = "https://api.aerisapi.com/forecasts/$encodedloc?filter=daynight&client_id=$client_id&client_secret=$client_secret";
$url .= "&limit=3" if $short;
#print "$url\n";
open (HTTP, '-|', "curl --max-time 10 -s -k -L '$url'");
local $/;   # read entire file -- FIXME: potentially memory hungry
my $json = <HTTP>;
close(HTTP);
#print "$json\n";
if (not $json =~ /^\s*{/) {
  print "error1 while retrieving data: $json\n";
  exit $exitnonzeroonerror;
}
my $j = decode_json($json);

if (not $j->{success} or defined $j->{error}) {
  print "error2 while retrieving data: $j->{error}\n";
  exit $exitnonzeroonerror;
}

$ENV{TZ} = $j->{response}[0]->{profile}->{tz};

$lat = $j->{response}[0]->{loc}->{lat};
$lon = $j->{response}[0]->{loc}->{long};
print "Forecast for ", bold(geolocate($lat, $lon)), " ($lat, $lon):\n";

foreach my $period (@{$j->{response}[0]->{periods}}) {
  my $dow = strftime("%A", localtime($period->{timestamp}));
  my $emoji = " " . getEmojiFromIcon($period->{icon});
  if ($period->{isDay}) {
    printf " %s: %s%s; high: %d¬∞C/%d¬∞F", bold($dow), $period->{weather}, $emoji, $period->{maxTempC}, $period->{maxTempF};
  } else {
    printf " %s: %s%s; low: %d¬∞C/%d¬∞F", bold($dow . " night"), $period->{weather}, $emoji, $period->{minTempC}, $period->{minTempF};
  }
  if ($period->{snowCM} > 0.0) {
    printf "; snow: %dcm/%din", round($period->{snowCM}), round($period->{snowIN});
  } elsif ($period->{precipMM} > 0.0 and $short == 0) {
    printf "; precip: %0.1fmm/%0.1fin", round($period->{precipMM}), round($period->{precipIN});
  }
  print "\n";
}

#---------- alerts

$url = "https://api.aerisapi.com/alerts/$encodedloc?client_id=$client_id&client_secret=$client_secret";
#print "$url\n";
open (HTTP, '-|', "curl --max-time 10 -s -k -L '$url'");
local $/;   # read entire file -- FIXME: potentially memory hungry
$json = <HTTP>;
close(HTTP);
#print "$json\n";

if (not $json =~ /^\s*{/) {
  print "error1 while retrieving data: $json\n";
  exit $exitnonzeroonerror;
}
$j = decode_json($json);

if (not $j->{success} or (defined $j->{error} and $j->{error}->{code} ne "warn_no_data")) {
  print "error2 while retrieving data: $j->{error}\n";
  exit $exitnonzeroonerror;
}

if (defined $j->{response}) {
  foreach my $alert (@{$j->{response}}) {
    my $body = $alert->{details}->{body};
    $body =~ s/\n/ /g;
    $body =~ s/\* WH(AT|ERE|EN)//g;
    $body =~ s/\* IMPACTS//g;
    $body =~ s/\.\.\.\s*\.\.\./.../g;
    $body =~ s/  / /g;
    $body =~ s/\.\.\./‚Ä¶/g;
    $body = substr($body, 0, 200) if $short == 1;
    $body .= "‚Ä¶" if $short == 1;
    
    my $name = $alert->{details}->{name};
    $name = red($name) if $alert->{details}->{emergency};
    $name = yellow($name) if not $alert->{details}->{emergency};
    printf " %s: %s\n", $name, $body;
  }
}

sub getEmojiFromIcon {
  my $icon = shift;
  our %iconToEmojiMap;
  #print "$icon :: $iconToEmojiMap{$icon}\n";
  #print "$icon\n";
  if (defined $iconToEmojiMap{$icon}) {
    return $iconToEmojiMap{$icon} . " ";
  } else {
    $icon =~ s/\.png$//;
    #return "[$icon]";
    return "";
  }
}
