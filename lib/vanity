#!/usr/bin/perl -w
#
# Pull info from FCC database
#
# 2-clause BSD license.
# Copyright (c) 2019, 2020, 2021 molo1134@github. All rights reserved.

use strict;
use utf8;
use feature 'unicode_strings';
binmode(STDOUT, ":utf8");


use File::Basename;
use Cwd 'realpath';
use lib dirname(realpath(__FILE__));
use Colors;
use Util;

use Time::Local;
use Time::Piece ();
use List::Util qw[min max];
use POSIX qw(strftime);

# disable "experimental" warning on smart match operator use
no if $] >= 5.018, warnings => "experimental::smartmatch";

my $username = $ENV{'USER'} || $ENV{'USERNAME'} || getpwuid($<);
my $highlight="vt220";
$highlight = "none" if ! -t STDOUT;
$highlight = "irc" if $username eq getEggdropUID();

my $predictionBaseUrl = "http://34.121.48.146:8018/predict-fcc/";

# change this to 0 to always exit with success
our $exitnonzeroonerror = 1;
$exitnonzeroonerror = 0 if $username eq getEggdropUID();

# eggdrop doesn't split args on spaces
@ARGV=split(' ', join(' ',@ARGV));
@ARGV = uniq(@ARGV);	# deduplicate - no reason to process the same url twice

if ($#ARGV < 0 || length($ARGV[0]) == 0) {
  if ($username eq getEggdropUID()) {
    print "usage: !vanity <call>|<region/AK/HI/territory>\n";
  } else {
    print "usage: $0 <call>|<region/AK/HI/territory>\n";
  }
  exit $exitnonzeroonerror;
}

my $httpTimeout = 5;
my $i = 0;
while ($i <= $#ARGV) {

  $ARGV[$i] =~ s/'//g; # sanitize

  if ($ARGV[$i] =~ m/^[0-9]+$/) {
    if ($ARGV[$i] == 12) {
      doRegion("12_PR");
      doRegion("12_VI");
    } elsif ($ARGV[$i] == 13) {
      doRegion("13_HI");
      doRegion("13_GU");
      doRegion("13_AS");
      doRegion("13_MP");
    } elsif ($ARGV[$i] > 13 and length($ARGV[$i]) == 10) {
      doApp($ARGV[$i]);
    } elsif ($ARGV[$i] > 13) {
      print "invalid region\n";
      exit $exitnonzeroonerror;
    } else {
      doRegion($ARGV[$i]);
    }
  } else {
    if ($ARGV[$i] eq "AK") {
      doRegion(11);
    } elsif ($ARGV[$i] eq "HI") {
      doRegion("13_HI");
    } elsif ($ARGV[$i] eq "GU") {
      doRegion("13_GU");
    } elsif ($ARGV[$i] eq "AS") {
      doRegion("13_AS");
    } elsif ($ARGV[$i] eq "MP") {
      doRegion("13_MP");
    } elsif ($ARGV[$i] eq "PR") {
      doRegion("12_PR");
    } elsif ($ARGV[$i] eq "VI") {
      doRegion("12_VI");
    } else {
      doCall($ARGV[$i]);
    }
  }
  $i++;
}

sub doRegion {
  my $region = shift;
  my $saved = $_;
  $region = 10 if isNumeric($region) and $region == 0;
  my $url = "$predictionBaseUrl/shortcalls-$region.csv";
  
  my @avail;
  my @pending;
  my @upcoming;
  my @unavail;
  my %regionPreds;
  open(HTTP, '-|', "curl --max-time $httpTimeout -L -k -s '$url'");
  while(<HTTP>) {
    chomp;
    next if /^#/;
    my ($call, $status, $odds) = split /,/;
    push @avail, $call if $status eq "available";
    push @unavail, $call if $status eq "blocked";
    push @upcoming, $call if $status eq "upcoming";
    push @pending, $call if $status eq "pending";
    $regionPreds{$call} = $odds if $status eq "pending";
  }
  close(HTTP);

  print "Region $region: ", green(scalar @avail), " available";

  if (scalar @avail > 0) {
    #print ": ", green(join(", ", @avail));
    my $num = 0;
    print ": ";
    foreach my $c (@avail) {
      print green($c);
      print yellow(" ($regionPreds{$c}%)") # \
	if defined $regionPreds{$c} and $regionPreds{$c} > 0.0;
      if ($num >= 30) {
	print " (truncated)";
	last;
      }
      print ", " unless ++$num == scalar @avail;
    }
  }

  print "; ", lightblue(scalar @pending), " pending";

  if (scalar @pending > 0) {
    my $num = 0;
    print ": ";
    foreach my $c (@pending) {
      print lightblue($c);
      print yellow(" ($regionPreds{$c}%)") # \
	if defined $regionPreds{$c} and $regionPreds{$c} < 99.5; # allow for rounding
      print ", " unless ++$num == scalar @pending;
    }
    #print ": ", lightblue(join(", ", @pending)) if scalar @pending > 0;
  }

  print "; ", yellow(scalar @upcoming), " upcoming";
  print ": ", yellow(join(", ", @upcoming)) if scalar @upcoming > 0;
  print "; ", red(scalar @unavail), " unavailable: ",
	red(join(", ", @unavail)) if scalar @unavail > 0;
  print "\n";
  $_ = $saved;
}

sub doCall {
  my $call = uc shift;
  my $saved = $_;

  my ($frn, $name, $class, $status, $state, $grant, $eff, $cxl, $expire);
  my $availdate;
  my ($receipt, $process, $appl, $filenum, $type, $seq, $pred);
  my $callStatus;
  my $found = 0;
  my @frns;
  my %odds_sim;

  my $url = "${predictionBaseUrl}/vanity-$call.csv";
  open(CSV, '-|', "curl --fail --max-time $httpTimeout -L -k -s '$url'");
  while(<CSV>) {
    chomp;
    next if /^#/;
    my ($appid, $rdate, $pdate, $appcall, $state, $seq, $vanity, $pred, $odds) = split /,/;
    $odds = formatOdds($odds);
    $pred = formatPred($pred);
    $pdate = " ?        " if $pdate eq "";
    $seq = "$seq/?";		# TODO FIXME
    printf "$rdate -> $pdate %-6s ($state) App $appid #%-5s $pred%s\n", $appcall, $seq, $odds;
    $found = 1;
  }
  close(CSV);

  $url = "${predictionBaseUrl}/call-$call.csv";
  open(CSV, '-|', "curl --fail --max-time $httpTimeout -L -k -s '$url'");
  while(<CSV>) {
    chomp;
    next if /^#/;
    my ($appid, $rdate, $pdate, $call, $state, $seq, $vanity, $pred, $odds) = split /,/;
    $pdate = " ?        " if $pdate eq "";
    my $type = "type?";		# TODO FIXME
    $odds = formatOdds($odds);
    $pred = formatPred($pred);
    print "$rdate -> $pdate App $appid ($type) #$seq $vanity $pred$odds\n";
    $found = 1;
  }
  close(CSV);

  print "no pending applications found matching $call\n" if $found == 0;
#  print bold($call), ": $callStatus\n" if defined $callStatus and not $found;
  $_ = $saved;
}

sub doApp {
  my $app = shift;
  my $url = "${predictionBaseUrl}/app-$app.csv";
  open(CSV, '-|', "curl --fail --max-time $httpTimeout -L -k -s '$url'");
  while(<CSV>) {
    chomp;
    next if /^#/;
    my ($appid, $rdate, $pdate, $call, $state, $seq, $vanity, $pred, $odds) = split /,/;
    $pdate = " ?        " if $pdate eq "";
    my $type = "type?";		# TODO FIXME
    $odds = formatOdds($odds);
    $pred = formatPred($pred);
    print "$rdate -> $pdate App $appid ($type) #$seq $vanity $pred$odds\n";
  }
  close(CSV);
}

sub uniq {
  my %seen;
  grep !$seen{$_}++, @_;
}

sub formatOdds {
  my $odds = shift;
  if (not defined $odds or length($odds) == 0) {
    $odds = "";
  } else {
    if (isNumeric($odds) and $odds == 100.0) {
      $odds = green(" 100%");
    } elsif (isNumeric($odds) and $odds == 0.0) {
      $odds = red(" 0%");
    } else {
      $odds = yellow(" $odds%");
    }
  }
  return $odds;
}

sub formatPred {
  my $pred = shift;
  $pred =~ s/_/ /g;
  $pred = green($pred) if $pred eq "Assignment";
  $pred = lightblue($pred) if $pred =~ /^(Competition|Available)/;
  $pred = italic($pred) if $pred =~ /^Unneeded/;
  $pred = yellow($pred) if $pred =~ /^Offlined/;
  $pred = red($pred) if $pred =~ /^(Too|Not|Invalid|Insuff|Restricted|Active|Duplic|Reserv|Inactive|Block)/;
  return $pred;
}


